---
layout: post
title: The Ubiquitous UART
categories: misc
---

Practically everyone who has dealt with embedded systems at some point in their life has heard of UART. It's one of the most popular communication interfaces and remains so despite its age due to its simplicity and ease of use.

# What is UART?
UART is short for Universal Asynchronous Receiver/Transmitter. It is a moderate speed communication interface capable of full-duplex communication (meaning it can transmit and receive data at the same time). 

A UART interface consists of 2 signals, TX (transmit) and RX (receive) along with a ground wire. 
![image](/assets/UART.webp)

The asynchronous nature of UART means that it doesn't use a clock signal to pace the transfer of data unlike other communication protocols you may have heard of such as SPI and I2C. But technically, there are clock signals being used, not for synchronizing the transmitter and receiver but internally in the transmitter and receiver that govern how the data is generated and interpreted. These internal clock signals must be sufficiently accurate to the expected frequency of the data transfer and stable. 

# Looking into the bits
![image](/assets/uart_bit.webp)
Each UART transmission typically sends 8 data bits or 1 byte. It doesn't need to be 8 bits (can be anywhere from between 5 to 9) but 8 bits is the most common length as it is exactly 1 byte.

The start and stop of a UART transmission is denoted by a **start bit** and a **stop bit** respectively. 

The start bit indicates to the receiver that the data line is going to leave its idle state. The idle state is a logic high, so the start bit is a logic low and hence the start of a transmission can be characterized by a falling edge. 

The stop bit has the same logic level as the idle state (i.e. logic high) and indicates the end of the transmission, characterized as a rising edge.

UART transmissions may also sometimes employ **parity bits**. Parity bits are error-detection bits added to at end of the data bits. There are typically four types of parity used in UART which are -- odd, even, mark and space

Odd parity means that the parity bit will be a '1' if the data byte contains an even number of '1's whereas even parity means that the parity bit will be a '1' if the data byte contains an odd number of'1's. The idea is to ensure that the number of '1's matches the type of parity (i.e. even number of '1's for even parity and odd number of '1's for odd parity). 

Mark and space parity is a simpler form of parity where the parity is always set to '1' (for mark parity) or '0' (for space parity).

Parity bits provide a simple error-detection mechanism, if a bit gets flipped somewhere in the transmission process, the number of '1's no longer matches the parity. Hence the receiver knows that the received data is erroneous. Of course, this strategy doesn't work at all if two bits are flipped so the parity bit is far from a foolproof solution. However, the use cases of UART are generally simple enough that error detection/correction isn't really a big concern.

The data rate of the UART transmission is determined by the **baud rate**, which denotes the number of bits transferred per second. More specifically, it is the frequency that corresponds to the bit period (time required to transmit one bit of data). In real life, the system can't actually transfer data at exactly the baud rate as there can be overhead from things like the start and stop bits, parity bits, delays, etc. 

# Sampling the bits
![image](/assets/uart_sample.png)
Data signals are simply just transitions between a logic low and a logic high (or vice versa). These logic states must be sampled by the receiver in order to convert it to data. 

In UART, the transmitted bits on the data lines are sampled in the middle of the bit period. This is done because sampling in the middle helps avoid sampling errors due to clock frequency differences between the receiver and transmitter. If you were to sample close to the start or end of a bit and there's some clock drift, you might accidentally end up sampling the bit before/after the one you actually intended to sample. 

However there's a catch here: UART is *asynchronous*, it doesn't use a clock signal to pace the data transfer. So how does the receiver know when to sample the bits on the data line? Well of course there is the start bit, but since the transmitter and receiver clocks are independent, the falling edge of the start bit can practically fall at any point in the receiver's clock cycle. In other words, the receiver can miss it. Even if it does manage to catch it, the receiver won't know whether it has detected the very start of the falling edge, or the very end. 

The solution to this lies in oversampling. Typically, the receiver is configured to sample the data lines at 8, 16 or even 32 times the baud rate of the UART interface. The oversampling factor is equal to the number of clock cycles per bit. This is because the transmitter generates the data bits at a rate equal to the baud rate of the system and the receiver is oversampling. 

The higher the degree of oversampling, the more robust the system is. With 16x oversampling, the start bit edge detection is accurate is 1/16 (6.25%) of the bit length and can sample data bits with no more than 6.25% deviation from the middle of the bit period. 

So with that in mind, let's see how a UART transaction works. Let's assume we're working with a 16x oversampling system. 
- Firstly, the falling edge of the start bit is detected. This lets the receiver know that a transmission is starting. 
- The receiver then looks for the middle of the start bit's bit period by waiting for clock cycles equal to half the number of clock cycles per bit. In this case, since the number of clock cycles per bit is 16, it waits for 8 clock cycles. The purpose of this is so that it can sample the incoming data bit at the middle of their bit period. 
- Now at the middle of the start bit's period, the receiver then waits for 16 more clock cycles, equal to the number of clock cycles per bit. This will bring it to the middle of the first data bit's period. At this point, the receiver samples the data line, picking up the first data bit and storing it in memory. 
- The receiver then waits another 16 clock cycles before sampling the next data bit. This process repeats until all the data bits have been sampled and stored. The rising edge of the stop bit denotes the end of the transaction and returns the interface to the idle state. 

# Synchronous UART?
You may have come across the term USART before, which stands for Universal **Synchronous**/Asynchronous Receiver/Transmitter. Basically just UART but with "synchronous" added on to it. 

USART is essentially a fancier UART interface, with the ability to be configured in synchronous or asynchronous mode. This means that in addition to the UART protocol, it can also be set up for synchronous communications with a clock signal to pace the transfer. 