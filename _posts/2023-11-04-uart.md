---
layout: post
title: Embedded Systems Part 1 - The Ubiquitous UART
categories: misc
---

This is part 1 of a series of posts related to basic concepts in embedded systems. I may not write about everything but I'd like to cover as much as possible especially some of the more important stuff. 

Practically everyone who has dealt with embedded systems at some point in their life has heard of UART. It's one of the most popular communication interfaces and remains so despite its age due to its simplicity and ease of use.

# What is UART?
UART is short for Universal Asynchronous Receiver/Transmitter. It is a moderate speed communication interface capable of full-duplex communication (meaning it can transmit and receive data at the same time). 

A UART interface consists of 2 signals, TX (transmit) and RX (receive) along with a ground wire. 
![image](/assets/UART.webp)

The asynchronous nature of UART means that it doesn't use a clock signal to pace the transfer of data unlike other communication protocols you may have heard of such as SPI and I2C. But technically, there are clock signals being used, not for synchronizing the transmitter and receiver but internally in the transmitter and receiver that govern how the data is generated and interpreted. These internal clock signals must be sufficiently accurate to the expected frequency of the data transfer and stable. 

# Looking into the bits
![image](/assets/uart_bit.webp)
Each UART transmission typically sends 8 data bits or 1 byte. It doesn't need to be 8 bits (can be anywhere from between 5 to 9) but 8 bits is the most common length as it is exactly 1 byte.

The start and stop of a UART transmission is denoted by a **start bit** and a **stop bit** respectively. 

The start bit indicates to the receiver that the data line is going to leave its idle state. The idle state is a logic high, so the start bit is a logic low and hence the start of a transmission can be characterized by a falling edge. 

The stop bit has the same logic level as the idle state (i.e. logic high) and indicates the end of the transmission. Note that you can't characterize the stop bit as a rising edge because the 8th data bit can also be high. 

UART transmissions may also employ **parity bits**. Parity bits are error-detection bits added to at end of the data bits. There are typically four types of parity used in UART which are -- odd, even, mark and space.

Odd parity means that the parity bit will be a '1' if the data byte contains an even number of '1's whereas even parity means that the parity bit will be a '1' if the data byte contains an odd number of'1's. The idea is to ensure that the number of '1's matches the type of parity (i.e. even number of '1's for even parity and odd number of '1's for odd parity). 

Mark and space parity is a simpler form of parity where the parity is always set to '1' (for mark parity) or '0' (for space parity).

Parity bits provide a simple error-detection mechanism, if a bit gets flipped somewhere in the transmission process, the number of '1's no longer matches the parity. Hence the receiver knows that the received data is erroneous. Of course, this strategy doesn't work at all if two bits are flipped so the parity bit is far from a foolproof solution. However, the use cases of UART are generally simple enough that error detection/correction isn't really a big concern.

The data rate of the UART transmission is determined by the **baud rate**, which denotes the number of bits transferred per second. More specifically, it is the frequency that corresponds to the bit period (time required to transmit one bit of data). In real life, the system can't actually transfer data at exactly the baud rate as there can be overhead from things like the start and stop bits, parity bits, delays, etc. 

# Sampling the bits
![image](/assets/uart_sample.png)

To actually get the data, each bit on the data line must be sampled by the receiver. 

In UART, the transmitted bits on the data lines are sampled in the middle of the bit period. This is done because sampling in the middle helps avoid sampling errors due to clock frequency differences between the receiver and transmitter. If you were to sample close to the start or end of a bit and there's some clock drift, you might accidentally end up sampling the bit before/after the one you actually intended to sample. 

However there's a catch here: UART is *asynchronous*, so there's no clock telling when the transmitter should transmit data and when the receiver should receive the data. So how does the receiver know when to sample the bits on the data line? 

Well of course there is the start bit, but since the transmitter and receiver clocks are independent of each other, the start bit can fall in any point in the receiver's clock cycle. In other words, the receiver can miss it or even mistake one of the data bits as the start bit. Even if the start bit was correctly sampled, the receiver wouldn't know whether it has sampled the start bit too early or too late, causing timing errors with sampling the rest of the bits. 

The solution to this lies in *oversampling*. Typically, the receiver is configured to sample the data lines at 8x, 16x or even 32x the baud rate of the UART interface. The oversampling factor is equal to the number of clock cycles per bit, meaning that the system will sample the same bit for that number of clock cycles. 

The higher the degree of oversampling, the more robust the system is. With 16x oversampling, the start bit edge detection is accurate to 1/16 (6.25%) of the bit length and can sample data bits with no more than 6.25% deviation from the middle of the bit period. 

So with that in mind, let's see how a UART transaction works with a 16x oversampling system. 
- Firstly, the receiver looks for the falling edge of the start bit. This lets the receiver know that a transmission is starting. 
- The receiver then looks for the middle of the start bit's period by waiting for clock cycles equal to half the number of clock cycles per bit. In this case, since the number of clock cycles per bit is 16, it waits for 8 clock cycles. By knowing where the middle of the start bit's period is, further incoming bits can be sampled at the middle of their own bit period. 
- Now at the middle of the start bit's period, the receiver then waits for 16 more clock cycles, (AKA number of clock cycles per bit). This brings it to the middle of the first data bit's period and the first data bit is sampled, storing the data into a buffer.
- The receiver then waits another 16 clock cycles before sampling the next data bit. This process repeats until all the data bits have been sampled and stored. After for the predetermined number of data bits, the receiver then looks for the stop bit, characterized by a logic high.

It's important to note that UART data is shifted out LSB first. This means that if you send a bit sequence like '11100101', the receiver will instead see '10100111'. 

# Synchronous UART?
You may have come across the term USART before, which stands for Universal **Synchronous**/Asynchronous Receiver/Transmitter. Basically just UART but with "synchronous" added on to it. 

USART is essentially a fancier UART interface, with the ability to be configured in synchronous or asynchronous mode. This means that in addition to the UART protocol, it can also be set up for synchronous communications with a clock signal to pace the transfer. 